在该方法中，我们将字符串看成一个base 进制的数，它对应的十进制值就是哈希值。
显然，两个字符串的哈希值相等，当且仅当这两个字符串本身相同。然而如果字符串本身很长，其对应的十进制值在大多数语言中无法使用内置的整数类型进行存储。
因此，我们会将十进制值对一个大质数 mod 进行取模。此时：
  ·如果两个字符串的哈希值在取模后不相等，那么这两个字符串本身一定不相同；
  ·如果两个字符串的哈希值在取模后相等，并不能代表这两个字符串本身一定相同。
  例如两个字符串的哈希值分别为 2 和 15，模数为 13，虽然 2≡15(mod 13)（2和15同余），但它们不相同。

然而，我们在编码中使用的base 和 mod 对于测试数据本身是「黑盒」的，也就是说，并不存在一组测试数据，使得对于任意的base 和 mod，都会产生哈希碰撞，导致错误的判断结果。
因此，我们可以「投机取巧」地尝试不同的base 和 mod，使之可以通过所有的测试数据。
注意：在工程代码中，千万不能投机取巧。

一般来说，我们选取一个大于字符集大小（即字符串中可能出现的字符种类的数目）的质数作为 base，再选取一个在字符串长度平方级别左右的质数作为mod（比如1000000007），产生哈希碰撞的概率就会很低。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/shortest-palindrome/solution/zui-duan-hui-wen-chuan-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。