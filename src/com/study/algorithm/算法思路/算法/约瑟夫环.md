## 介绍
这个问题是以弗拉维奥·约瑟夫命名的，他是1世纪的一名犹太历史学家。

他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中。
他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。

**游戏规则如下：**

41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是一开始要站在什么地方才能避免自杀？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。
约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。
约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。 —— 【约瑟夫问题】维基百科

## 代码
可以将介绍简化下，n个人围成一圈，下标从0开始计数，每隔m个人，此人离开圈，下一个人重新计数，并再次离开第m的人，那么最后剩下的下标是多少。

```java
public int lastRemaining(int n, int m) {
    //我们将问题建模为函数 f(n, m)，该函数的返回值为最终留下的元素的序号。
    //很明显，最后当n=1时，这最后一个人所在的序号位置为标0，此为递归终止条件。
    //反推上去后，当n=2时，需要在之前的（n=1）下标0前再加入m个人后，即为这个幸存者的下标位置(0+m)%2，因只有2个人（n=2）
    //继续反推后，当n=3时，需要在之前的（n=2）下标前面加入m个人后，即为这个幸存者的下标位置((0+m)%2+m)%3
    //...
    //最后反推至n时，即可计算出f(n, m)的情况下，幸存者下标位置。
    if (n == 1) {
        return 0;
    }
    return (lastRemaining(n - 1, m) + m)% n;
}

public int lastRemainingByLeetCode(int n, int m) {
    //递归改为迭代，避免栈空间开销
    int f = 0;
    //最后一轮剩下2个人，所以从2开始反推
    for (int i = 2; i != n + 1; ++i) {
        f = (m + f) % i;
    }
    return f;
}

```