1. `x/y` 向上取整:
    1. `x/y + if(x%y==0) 0 else 1`,前面表示取整运算,后面表示如果有余数则+1
    2. `Math.ceil(x/y)`,自带的运算函数
    3. `(x+y-1)/y`

2. Brian Kernighan算法可以用于清除二进制数中最右侧的1。
   Brian Kernighan算法的做法是先将当前数减一，然后在与当前数进行按位与运算。`x=x&(x-1)`

3. 最低设置位:一个数x的最低设置位为,其二进制表示下,最低的1所在位.
   比如十进制表示的数字10(10),二进制表示为1010(2),那么最高有效位就是10(2),也就是2(10).
   求一个数的最低设置位有以下方法:
    1. `x&(-x)`,这是因为 (-x) 在计算机中以补码的形式存储，它等于 ~x+1。
    2. `x^(x&(x-1))`,`x&(x-1)`表示消除最低位1,两个数再进行异或(^)操作后,就可以得到最低的1所在位

4. 最低有效位(区分与最低设置位):一个数x,其二进制表示的最低位,也就是x除以2的余数.求一个数的最低有效位有以下方法:
    1. `x%2`
    2. `x&1`

5. 最高有效位:一个数x的最高有效位为,其二进制表示下,最高的1所在位.
   比如十进制表示的数字10(10),二进制表示为1010(2),那么最高有效位就是1000(2),也就是8(10).
   求一个数的最高有效位有以下方法:
    1. 每次消除最低位'1',直到只剩一个1为止:
   ```java
   public int highestOneBit(int num) {
        int res = 0;
        while (num != 0) {
            res = num;
            num = num & (num - 1);
        }
        return res;
    }
   ```
    2. 将数字x最高位的后几位的0全部填充为1得到数字x2,输出x2-(x2>>>1):
   ```java
   public int highestOneBit(int num) {
        num |= num >>> 1;
        num |= num >>> 2;
        num |= num >>> 4;
        num |= num >>> 8;
        num |= num >>> 16;
        return num - (num >>> 1);
    }
   ```
    3. `Integer.highestOneBit(num)`,其实内部实现就是方式2