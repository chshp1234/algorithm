package com.study.algorithm.algorithms;

import org.junit.Test;

//可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
//'A'：Absent，缺勤
//'L'：Late，迟到
//'P'：Present，到场
//如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：
//
//按 总出勤 计，学生缺勤（'A'）严格 少于两天。
//学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。
//给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 的结果。
//
// 
//
//示例 1：
//
//输入：n = 2
//输出：8
//解释：
//有 8 种长度为 2 的记录将被视为可奖励：
//"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL"
//只有"AA"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。
//示例 2：
//
//输入：n = 1
//输出：3
//示例 3：
//
//输入：n = 10101
//输出：183236316
// 
//
//提示：
//
//1 <= n <= 105
//
//来源：力扣（LeetCode）
//链接：https://leetcode-cn.com/problems/student-attendance-record-ii
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
public class 学生出勤记录II {
    @Test
    public void 学生出勤记录II() {
        System.out.println("学生出勤记录II:" + checkRecord(10101));
    }

    public int checkRecord(int days) {
        //动态规划，时间复杂度O(n),空间复杂度O(1)

        //我们可以确定，从第1天到n天，该学生都可以获得出勤奖励（中途断了，肯定不行）
        //那么可以是用动态规划进行解答，第n天可以获得出勤奖的记录情况，肯定是由的n-1天可以获得出勤奖的记录情况转移而来
        //1.首先我们确定几种可以获得出勤奖励的情况：
        // a0l0，a0l1，a0l2，a1l0，a1l1，a1l2，a代表缺勤记录情况，l代表连续迟到的记录情况，（p正常出勤肯定不用考虑了），
        // a0l0,代表缺勤记录0天，连续迟到0天；a1l1代表缺勤记录1天，连续迟到记录1天...其他类似
        //2.那么状态dp[n][0...5],表示第n天时，出勤记录情况分别为a0l0，a0l1...a1l2的天数
        //3.dp[n][0]=dp[n-1][0]+dp[n-1][1]+dp[n-1][2],啥意思呢，就是说第n天时出勤记录是“缺勤0天，连续迟到0天”这种情况的总天数是等于多少，
        //因为整体有缺勤时，就一直都有缺勤记录了，那么在这之后都不能有缺勤，而迟到是只算连续的，也就是不管之前（n-1）连续迟到了1天2天还是没有迟到，如果这天（n）我是到场(p)或者缺勤(a)，那么连续迟到的记录都会打破，此时l就都为0（荒唐啊）。
        //所以第n天时出勤记录是“缺勤0天，连续迟到0天”这种情况dp[n][0]，只能由第n-1天时，“缺勤0天，连续迟到（0、1、2）天”时的情况到第n天时是正常出勤时获得（转移而来）
        //4.dp[n][1]=dp[n-1][0],这又是啥意思呢？dp[n][1]代表第n天“缺勤0天，连续迟到1天”记录的情况，那么同样，在此之前都不能有缺勤的情况，而且也不能有连续迟到，此时，第n天，迟到了就会得到a0l1了。
        //5.dp[n][2]、dp[n][4]、dp[n][5]同dp[n][1]一样理解（4，5就是缺勤只有一天的情况）
        //6.再讲下dp[n][3]的情况，dp[n][3]代表a1l0,也就是第n天出勤记录是“缺勤1天，连续迟到0天的情况”，状态方程是dp[n][3]=dp[n-1][0]+dp[n-1][1]+dp[n-1][2]+dp[n-1][3]+dp[n-1][4]+dp[n-1][5]
        //这里相比dp[n][0]，把之前所有情况都加上去了，原因也很简单，同样是当天出勤为p和a时可以打破连续迟到这种情况，那么第n-1天时既可以有缺勤也可以没有缺勤，
        //其中没有缺勤就是前三种状态，此时第n天只要是缺勤，就可以达到此状态，而有缺勤就是后三种状态，此时第n天只要出勤就可以达到此状态
        //7.列好状态，写好状态转移方程，那么结果呢，第n天总的记录情况怎么获得。
        //我们假设第n天的结果总和为result，那么result=(dp[n-1][0]+dp[n-1][1])*3+(dp[n-1][2]+dp[n-1][3]+dp[n-1][4])*2+(dp[n-1][5])
        //我们分3个括号进行解释：
        //（1）.第n-1天为“缺勤0天，连续迟到0天”或者“缺勤0天，连续迟到1天”时，那么对于第n天，既可以迟到，又可以缺勤，当然更加可以正常出勤，所以是两种状态相加后再*3
        //（2）.第n-1天为“缺勤0天，连续迟到2天”时，第n天可以缺勤，也可以正常出勤（不能再迟到了），第n-1天为“缺勤1天，连续迟到0天”或者“缺勤1天，连续迟到1天”，那么第n天可以是迟到也可以是正常出勤（不能再缺勤了），所以是这三种状态相加后再*2
        //（3）.第n-1天为“缺勤1天，连续迟到2天”时，那么第n天只能正常出勤，所以只加上这一中状态

        //最后只要返回result即可，这里我们看到不管是第n天时的各种状态还是总的记录情况，都只跟第n-1天有关，所以可以简化为使用滚动数组。


        //只有1天时，3种情况都可以
        if (days == 1) {
            return 3;
        }

        //结果
        long result;

        //状态，只有这几种状态才能获得出勤奖励
        //dp[n][0]:第n天时，出勤记录为“缺勤0天，连续迟到0天”的情况总和
        //dp[n][0]:第n天时，出勤记录为“缺勤0天，连续迟到1天”的情况总和
        //dp[n][0]:第n天时，出勤记录为“缺勤0天，连续迟到2天”的情况总和
        //dp[n][0]:第n天时，出勤记录为“缺勤1天，连续迟到0天”的情况总和
        //dp[n][0]:第n天时，出勤记录为“缺勤1天，连续迟到1天”的情况总和
        //dp[n][0]:第n天时，出勤记录为“缺勤1天，连续迟到2天”的情况总和
        long[][] dp = new long[2][6];
        dp[1][0] = 1;
        dp[1][1] = 1;
        dp[1][3] = 1;

        for (int i = 2; i <= days; i++) {

            //记录第n-1天的状态
            dp[0][0] = dp[1][0];
            dp[0][1] = dp[1][1];
            dp[0][2] = dp[1][2];
            dp[0][3] = dp[1][3];
            dp[0][4] = dp[1][4];
            dp[0][5] = dp[1][5];

            //第n天的状态由n-1天状态得来
            dp[1][0] = (dp[0][0] + dp[0][1] + dp[0][2]) % 1000000007;
            dp[1][1] = dp[0][0];
            dp[1][2] = dp[0][1];
            dp[1][3] = (dp[0][0] + dp[0][1] + dp[0][2] + dp[0][3] + dp[0][4] + dp[0][5]) % 1000000007;
            dp[1][4] = dp[0][3];
            dp[1][5] = dp[0][4];

        }

        //第n天总的出勤记录总数
        result = ((dp[0][0] + dp[0][1]) * 3L + (dp[0][2] + dp[0][3] + dp[0][4]) * 2L + dp[0][5]) % 1000000007;

        return (int) result;
    }
}
