package com.study.algorithm.algorithms;

import java.util.Arrays;

//元素的 频数 是该元素在一个数组中出现的次数。
//
//给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。
//
//执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。
//
// 
//
//示例 1：
//
//输入：nums = [1,2,4], k = 5
//输出：3
//解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。
//4 是数组中最高频元素，频数是 3 。
//示例 2：
//
//输入：nums = [1,4,8,13], k = 5
//输出：2
//解释：存在多种最优解决方案：
//- 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。
//- 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。
//- 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。
//示例 3：
//
//输入：nums = [3,9,6], k = 2
//输出：1
// 
//
//提示：
//
//1 <= nums.length <= 105
//1 <= nums[i] <= 105
//1 <= k <= 105
//
//来源：力扣（LeetCode）
//链接：https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
public class 最高频元素的频数 {

    //排序+滑动窗口
    //因为元素值只能向上增加,所以我们先对数组进行从小到大排序,这样只能由前面的元素值增加使得和后面的值相同.对于频次计算,我们使用滑动窗口.
    //
    //1.假设区间(l...r)元素进行增加后符合条件,那么说明区间和sum(l..r)+k>=(r-l+1)*r.
    //判断式左边部分代表对区间元素进行增加后的值,那右边呢?
    //首先因为数组已经是有序递增了,那么num[r]的值肯定是最大的,只有可能是r左边部分的值进行增加到num[r]为止(没必要加多),所以(r-l+1)是区间元素的个数.
    //2.如果区间元素(l...r)不符合条件,那么区间和sum(l..r)+k<(r-l+1)*r.说明区间的元素和全部加上k个值后,还是达不到目标值,那么这个区间就不能作为一个可行解存在.

    //具体步骤:
    //1.初始化左右指针,左指针在下标0处,右指针在下标1处(只有一个元素的话没必要做增加操作,只有两个元素相比较才需判断是否需要增加)
    //2.右指针开始移动,若右指针指向的元素和上一个元素不相同,那么此区间前面的元素值就需要进行增加,使得值都和num[r]相同;若右指针指向的元素和上一个元素相同,则不用做处理.
    //3.判断区间内增加的值是否大于k,若大于k,说明此区间已不符合条件,那么左指针右移,并且,增加的值需要减去(nums[r]-nums[l])的差值,因为左指针处的元素已经不用增加了.
    //4.最后(和官方不同的地方)返回的答案就是nums.length-l,因为我们维护的是个最大窗口,此时的区间(l...r)可能不符合条件,但在遍历过程中窗口是缓慢增大的,总有个区间(最少一个元素,此时不必增加)是符合条件的.
    //
    //作者：chshp
    //链接：https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/solution/pai-xu-zui-da-hua-dong-chuang-kou-by-chs-45fl/
    //来源：力扣（LeetCode）
    //著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
    public int maxFrequency(int[] nums, int k) {
        int len = nums.length;
        //排序,方便后续遍历统计
        Arrays.sort(nums);
        //左指针,右指针遍历过程中直接维护
        int l = 0;
        //遍历过程中维护窗口最大化
        for (int i = 1; i < len; i++) {
            //如果当前元素和上一个元素值不同,那么对前面部分元素进行增加值,这里我们直接对k进行相减
            if (nums[i] != nums[i - 1]) {
                k -= (nums[i] - nums[i - 1]) * (i - l);
            }
            //如果k<0,说明此区间不符合条件(需要增加的值的大小>k);否则说明此区间符合条件,那么继续右指针右移
            if (k < 0) {
                //注意,先对k进行相加(重新把左指针处的值加回来)
                k += nums[i] - nums[l];
                //再进行左指针右移
                l++;
            }
        }
        //答案就是nums.length-l
        return len - l;
    }

}
