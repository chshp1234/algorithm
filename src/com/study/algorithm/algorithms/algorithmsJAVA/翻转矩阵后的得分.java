package com.study.algorithm.algorithms.algorithmsJAVA;

import org.junit.Test;

// 有一个二维矩阵 A 其中每个元素的值为 0 或 1 。
//
// 移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。
//
// 在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。
//
// 返回尽可能高的分数。
//
//
//
// 示例：
//
// 输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
// 输出：39
// 解释：
// 转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
// 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
//
//
// 提示：
//
// 1 <= A.length <= 20
// 1 <= A[0].length <= 20
// A[i][j] 是 0 或 1
//
// 来源：力扣（LeetCode）
// 链接：https://leetcode-cn.com/problems/score-after-flipping-matrix
// 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
public class 翻转矩阵后的得分 {
    @Test
    public void 翻转矩阵后的得分() {
        int[][] arrs = {{0, 0, 1, 1}, {1, 0, 1, 0}, {1, 1, 0, 0}};

        System.out.println("翻转矩阵后的得分：" + matrixScore(arrs));
    }

    public int matrixScore(int[][] A) {
        // 贪心
        // 要想使得和最大，那么每个数最高位必须为‘1’。
        // 我们可以先按每行进行翻转，把所有高位都转换成‘1’，或者所有高位都转换成‘0’。如果所有高位都转换成‘0’，再对这一列进行翻转，使都成为‘1’即可。
        // 之后不管高位是如何转换的，最终都会成为‘1’。
        // 再对后续每一位进行统计，统计每个数字中，这一位的‘1’的数量。
        // 若‘1’的数量小于等于数字个数（行数）的一半，则对该列进行翻转，翻转后‘1’的数量将大于等于数字个数（行数）的一半。这就满足了在这一位中，和最大。
        // 统计完毕后就，就可以进行最后的数字相加了。
        // 根据每一位中‘1’的个数，若个数是奇数，则相加后此位为‘1’，否则为‘0’；
        // 再对个数进行进位，每进一位，个数/2，再用此进位数加上此位上‘1’的数量；
        // 反复进行上述操作，直到进位数为0。

        // 在实际操作计算中，我们不用真的对原数组进行翻转，只需要计算翻转后，每一位中‘1’的个数，即可计算最后的相加结果。

        int row = A.length;
        int col = A[0].length;

        // 统计每一位中‘1’的数量
        int[] numOfOne = new int[col];

        // 要想使得结果和最大，最高位必须为‘1’，所以‘1’的数量为行数
        numOfOne[col - 1] = row;

        int result = 0;

        for (int r = 0; r < row; r++) {
            // 把‘0’翻转成1，若最高位为‘0’，则翻转
            boolean turn = (A[r][0] & 1) == 0;

            // 翻转后，‘0’变成‘1’，‘1’变成‘0’
            for (int c = 0; c < col - 1; c++) {
                // 若翻转，此位为‘0’则数量+1
                if (turn) {
                    numOfOne[c] += (A[r][col - c - 1] & 1) == 0 ? 1 : 0;
                }
                // 若不翻转，此位为‘1’则数量+1
                else {
                    numOfOne[c] += (A[r][col - c - 1] & 1) == 1 ? 1 : 0;
                }
            }
        }

        // 进位数
        int step = 0;
        // 按此位中，‘1’的数量和行数相比较
        for (int i = 0; i < col; i++) {
            // 此位‘1’的总数
            int numOne = (numOfOne[i] <= (row >> 1) ? row - numOfOne[i] : numOfOne[i]) + step;
            // 若总数为奇数，则相加后此位为‘0’，否则此位为‘1’
            result += (numOne % 2) << i;
            // 进位数=总数/2（表示每两个‘1’相加后进一位）
            step = numOne >> 1;
        }

        // 剩余位数
        int left = 0;
        while (step != 0) {
            // 若进位数不为0，说明计算还没结束

            // 此时这一位的‘1’的数量等于进位数
            int numOne = step;
            result += (numOne % 2) << (col + left);
            step = step >> 1;
            // 位数+1
            left++;
        }

        return result;
    }
}
