package com.study.algorithm.algorithms.algorithmsJAVA;

import org.junit.Test;

public class 求前n项和 {

    @Test
    public void 求和() {
        // 求 1+2+...+n
        System.out.println("求前n项和:" + sumNums(100));
    }
    /**
     * 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
     *
     * <p>
     *
     * <p>示例 1：
     *
     * <p>输入: n = 3 输出: 6 示例 2：
     *
     * <p>输入: n = 9 输出: 45
     *
     * <p>限制：
     *
     * <p>1 <= n <= 10000
     *
     * <p>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/qiu-12n-lcof
     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
     */
    public int sumNums(int n) {
        //                return IntStream.rangeClosed(1, n).sum();

        //        int sum = n;
        //        boolean b = (n > 0) && ((sum += sumNums(n - 1)) > 0);
        //        return sum;

        /**
         * 负数在参与位运算时使用的是补码
         *
         * <p>-1的原码是 10000000 00000000 00000000 00000001
         *
         * <p>-1的反码是 11111111 11111111 11111111 11111110
         *
         * <p>-1的补码是 11111111 11111111 11111111 11111111
         *
         * <p>因此任何数与-1做与(&)运算的结果任然为原数
         */
        /**
         * 由等差数列求和公式可知，结果等于n*(n+1)/2，其中除以2可以通过右移1位进行操作
         *
         * <p>但n*(n+1)在不允许使用乘法的情况下，只能把n或n+1其中一个拆解为2的n次幂数之和，配合另一个来进行位运算和累加
         *
         * <p>此代码利用了-1和任何整数进行与运算还等于原数的特点 -(n + 1 >> 0 & 1)用于求从低到高第i+1位如果为0取，如果为1取-1
         */
        /**
         * 倍增法，通过字面意思来看就是翻倍
         *
         * <p>使用1,2,4,8,16,32,64...8192这14个数便可求出10000以内所有数字
         */
        // 因为题目设定n<10000，n可能的最大拆分项为2^13=8192，问题是如何确定2的0-13次幂什么时候需要。
        // 比如11=8+2+1，只需要2的0、1、3次幂，所以要保证我们在加上其他次幂时无效。
        // 举例：(n>>>3)&1可以通过结果判断n的二进制第3位是0或者1，(0-((n>>>3)&1))可以决定此次相加是否有效，
        // 如果有效(0-((n>>>3)&1))=-1，然后(n+1)&(-1)=(n+1)还是其本身,
        // 再通过左移3位实现×8的效果，如果无效(0-((n>>>3)&1))=0，(n+1)&0=0,此时在左移3位，结果还是0.
        //
        // 作者：qiang_zi
        // 链接：https://leetcode-cn.com/problems/qiu-12n-lcof/solution/jie-guo-zui-bian-tai-de-yi-dao-ti-by-qiang_zi/
        // 来源：力扣（LeetCode）
        // 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
        int n1 = (n & -(n + 1 >>> 0 & 1)) << 0;
        int n2 = (n & -(n + 1 >>> 1 & 1)) << 1;
        int n3 = (n & -(n + 1 >>> 2 & 1)) << 2;
        int n4 = (n & -(n + 1 >>> 3 & 1)) << 3;
        int n5 = (n & -(n + 1 >>> 4 & 1)) << 4;
        int n6 = (n & -(n + 1 >>> 5 & 1)) << 5;
        int n7 = (n & -(n + 1 >>> 6 & 1)) << 6;
        int n8 = (n & -(n + 1 >>> 7 & 1)) << 7;
        int n9 = (n & -(n + 1 >>> 8 & 1)) << 8;
        int n10 = (n & -(n + 1 >>> 9 & 1)) << 9;
        int n11 = (n & -(n + 1 >>> 10 & 1)) << 10;
        int n12 = (n & -(n + 1 >>> 11 & 1)) << 11;
        int n13 = (n & -(n + 1 >>> 12 & 1)) << 12;
        int n14 = (n & -(n + 1 >>> 13 & 1)) << 13;
        return (n1 + n2 + n3 + n4 + n5 + n6 + n7 + n8 + n9 + n10 + n11 + n12 + n13 + n14) >>> 1;
    }
}
