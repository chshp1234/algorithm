package com.study.algorithm.algorithms.algorithmsJAVA;

import org.junit.Test;

import java.util.*;

//给你一个数组 routes ，表示一系列公交线路，其中每个 routes{i} 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。
//
//例如，路线 routes{0} = {1, 5, 7} 表示第 0 辆公交车会一直按序列 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... 这样的车站路线行驶。
//现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。
//
//求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。
//
// 
//
//示例 1：
//
//输入：routes = {{1,2,7},{3,6,7}}, source = 1, target = 6
//输出：2
//解释：最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。
//示例 2：
//
//输入：routes = {{7,12},{4,5,15},{6},{15,19},{9,12,13}}, source = 15, target = 12
//输出：-1
// 
//
//提示：
//
//1 <= routes.length <= 500.
//1 <= routes{i}.length <= 105
//routes{i} 中的所有值 互不相同
//sum(routes{i}.length) <= 105
//0 <= routes{i}{j} < 106
//0 <= source, target < 106
//
//来源：力扣（LeetCode）
//链接：https://leetcode-cn.com/problems/bus-routes
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
public class 公交路线 {
    @Test
    public void 公交路线() {
        System.out.println("公交路线：" + numBusesToDestination(new int[][]{
                {16, 17, 58, 72, 78, 83, 96, 98, 142, 161, 168}, {132}, {12, 18, 21, 36, 41, 43, 50, 51, 59, 62, 85, 86, 94, 97, 98, 106, 125, 132, 138, 146, 157, 158, 162, 164, 166, 170, 176}, {
                23, 34, 80, 113}, {14, 46, 75, 80, 97, 101, 107, 128, 138, 174, 178}, {39, 55, 65, 72, 136, 152, 177}, {
                1, 2, 5, 12, 16, 24, 28, 29, 39, 42, 50, 55, 65, 106, 110, 131, 132, 137, 142, 144, 145, 146, 149, 180, 183}, {
                4, 7, 48, 91, 97, 107, 122, 141, 162}, {
                6, 7, 13, 15, 18, 33, 39, 40, 46, 49, 51, 55, 58, 77, 92, 93, 94, 95, 97, 109, 128, 130, 139, 141, 145, 153, 154, 155, 161, 166, 181, 183}, {
                1, 3, 4, 5, 7, 22, 30, 36, 41, 42, 45, 46, 58, 59, 73, 80, 93, 96, 100, 113, 128, 134, 144, 161, 165, 173, 184}, {
                11, 43, 46, 47, 48, 52, 55, 62, 71, 79, 87, 88, 90, 92, 99, 103, 107, 109, 110, 115, 125, 135, 159, 175, 177, 180}, {
                14, 16, 33, 35, 44, 47, 59, 68, 73, 83, 89, 92, 102, 105, 110, 127, 128, 134, 146, 147, 153, 158, 163, 174, 178}, {
                32, 37, 63, 70, 118, 135, 180}, {12, 15, 53, 81, 104, 115, 142}, {
                3, 6, 9, 11, 13, 21, 23, 24, 34, 40, 41, 42, 45, 46, 49, 62, 70, 73, 80, 88, 93, 99, 102, 117, 122, 123, 128, 129, 130, 136, 157, 169}, {
                18, 25, 35, 47, 58, 64, 69, 85, 87, 102, 118, 131, 165, 171, 174, 177, 183}, {
                5, 7, 15, 17, 18, 23, 33, 38, 54, 70, 82, 95, 97, 101, 104, 122, 123, 137, 156, 160, 162, 164, 175, 179}, {
                1, 2, 10, 13, 14, 19, 21, 37, 50, 51, 60, 64, 65, 94, 96, 99, 113, 134, 143, 147, 166, 168, 170, 182}, {
                4, 11, 13, 30, 47, 49, 50, 59, 72, 74, 76, 80, 84, 96, 97, 102, 103, 105, 112, 121, 122, 132, 138, 146, 156, 158, 177, 181, 184}, {
                5, 9, 12, 16, 37, 39, 41, 43, 46, 53, 59, 66, 67, 77, 93, 96, 105, 117, 128, 135, 145, 147, 154, 158, 177, 182, 183}, {
                0, 2, 12, 29, 37, 40, 46, 48, 50, 59, 72, 75, 88, 94, 96, 119, 123, 127, 131, 133, 138, 140, 144, 147, 149, 151, 155, 157, 168, 171}, {
                1, 4, 8, 13, 14, 16, 30, 50, 66, 80, 85, 90, 95, 108, 111, 112, 126, 127, 130, 137, 140, 148, 150, 153, 154, 160, 184}, {
                9, 18, 23, 35, 38, 49, 56, 58, 60, 62, 73, 77, 86, 96, 98, 104, 110, 115, 123, 127, 130, 137, 143, 147, 148, 150, 153, 155, 162, 165, 171, 172, 173}, {
                10, 47, 63, 67, 105, 106, 116, 122, 144, 145, 164, 178}, {
                2, 4, 12, 13, 23, 31, 52, 68, 71, 80, 86, 95, 97, 107, 123, 130, 133, 141, 144, 155, 156, 157, 161, 167, 171, 177, 184}, {
                8, 19, 30, 44, 51, 56, 66, 73, 76, 92, 118, 123, 124, 126, 184}, {13, 15, 21, 22, 61, 65, 109, 160, 169}, {
                9, 14, 15, 16, 17, 32, 40, 49, 56, 57, 63, 64, 96, 97, 102, 107, 110, 113, 119, 120, 123, 137, 148, 149, 151, 154, 161, 163, 174, 176}, {
                173}, {0, 31, 118, 142, 143}, {
                9, 14, 22, 23, 34, 46, 49, 59, 68, 69, 71, 76, 78, 96, 97, 99, 116, 125, 136, 138, 147, 155, 172, 174, 176, 179, 180, 182}, {
                23, 43, 61, 63, 121, 138, 148}, {128, 133, 155}, {
                15, 22, 27, 39, 45, 55, 62, 79, 84, 93, 106, 110, 114, 125, 126, 129, 137, 145, 148, 150, 151, 154, 158, 165, 166, 178, 181}, {
                2, 6, 19, 21, 27, 43, 50, 54, 56, 67, 70, 88, 92, 108, 117, 123, 130, 134, 139, 151, 153, 160, 167}, {
                32, 100, 113, 162}, {
                2, 16, 17, 25, 26, 29, 39, 73, 81, 103, 109, 112, 123, 124, 127, 135, 149, 150, 153, 169, 170, 176, 178}}, 18, 113))
        ;
    }

//    int result = Integer.MAX_VALUE;
//    Map<Integer, Integer> busStep = new HashMap<>();

    Map<Integer, List<Integer>> bus = new HashMap<>();
    Map<Integer, Set<Integer>> busGraph = new HashMap<>();

    Set<Integer> end = new HashSet<>();
    List<Integer> start = new ArrayList<>();


    public int numBusesToDestination(int[][] routes, int source, int target) {
        //图，搜索
        //作每个公交车为一张图上的一个顶点，如果两个公交车有相同站点，那么这两个顶点相连
        //构图时，记录起始站点所属的公交，和结束站点所属的公交
        //那么我们只需找到从起始公交到结束公交最近的边数即可
        if (source == target) {
            return 0;
        }

        for (int i = 0, il = routes.length; i < il; i++) {
            for (int j = 0, jl = routes[i].length; j < jl; j++) {
                if (routes[i][j] == source) {
                    start.add(i);
                } else if (routes[i][j] == target) {
                    end.add(i);
                }

                List<Integer> list = bus.get(routes[i][j]);
                if (list == null) {
                    list = new ArrayList<>();
                    bus.put(routes[i][j], list);
                }
                list.add(i);

                //构图，找出经过这个站点其余的公交车，使得两个公交（顶点）相连
                for (int k = 0, kl = list.size(); k < kl; k++) {
                    Set<Integer> set = busGraph.get(i);
                    if (set == null) {
                        set = new HashSet<>();
                        busGraph.put(i, set);
                    }

                    if (i != list.get(k)) {
                        set.add(list.get(k));
                        busGraph.get(list.get(k)).add(i);
                    }
                }
            }
        }

        //bfs搜索
        Queue<Integer> deque = new LinkedList<>();
        for (int i = 0, l = start.size(); i < l; i++) {
            deque.offer(start.get(i));
        }

        int step = 0;
        Set<Integer> crossBus = new HashSet<>();
        while (!deque.isEmpty()) {
            step++;
            int size = deque.size();
            for (int i = 0; i < size; i++) {
                int busNow = deque.poll();
                crossBus.add(busNow);

                //广度优先搜索，当第一次遇到结束站点时，此时层级最少，就可以直接退出了
                if (end.contains(busNow)) {
                    return step;
                }

                //和顶点相连的边
                Set<Integer> edge = busGraph.get(busNow);
                for (int eb : edge) {
                    //判断此边是否遍历过
                    if (!crossBus.contains(eb)) {
                        deque.offer(eb);
                    }
                }
            }
        }

        return -1;
    }

    //dfs，递归太深会超时
//    public void dfs(int busNow, int step) {
//        if (step > result) {
//            return;
//        }
//        Integer busstep = busStep.get(busNow);
//        if (busstep == null) {
//            busStep.put(busNow, step);
//        } else if (step > busstep) {
//            return;
//        }
//        busStep.put(busNow, step);
//        if (end.contains(busNow)) {
//            result = step;
//            return;
//        }
//
//        List<Integer> roads = busGraph.get(busNow);
//        for (int i = 0, l = roads.size(); i < l; i++) {
//            List<Integer> buss = bus.get(roads.get(i));
//            for (int j = 0, jl = buss.size(); j < jl; j++) {
//                backTrack(buss.get(j), step + 1);
//
//            }
//        }
//    }
}
