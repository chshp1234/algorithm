package com.study.algorithm.algorithms.algorithmsJAVA;

//如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。
//
//给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。
//
//返回使 s 单调递增的最小翻转次数。
//
// 
//
//示例 1：
//
//输入：s = "00110"
//输出：1
//解释：翻转最后一位得到 00111.
//示例 2：
//
//输入：s = "010110"
//输出：2
//解释：翻转得到 011111，或者是 000111。
//示例 3：
//
//输入：s = "00011000"
//输出：2
//解释：翻转得到 00000000。
// 
//
//提示：
//
//1 <= s.length <= 105
//s[i] 为 '0' 或 '1'
//
//来源：力扣（LeetCode）
//链接：https://leetcode.cn/problems/flip-string-to-monotone-increasing
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
public class 将字符串翻转到单调递增 {
    public int minFlipsMonoIncr(String s) {
        //动态规划
        //设状态dp[i][0]为字符串中第i个字符为结尾，且字符为‘0’时，所需翻转的最小次数；dp[i][0]为字符串中第i个字符为结尾，且字符为‘1’时，所需翻转的最小次数。
        //当s[i]=='0'时，dp[i][0]=dp[i-1][0],因为要单点递增，上一个字符必须也是0；dp[i][1]=Math.min(dp[i-1][0],dp[i-1][1])+1,当前字符为1，上一个字符可以是1也可以是0，并且从0翻转到1次数加1
        //当s[i]=='1'时，dp[i][0]=dp[i-1][0]+1,同上，并且1翻转到0时需要次数+1;dp[i][1]=Math.min(dp[i-1][0],dp[i-1][1])，因为当前字符为1，那么不需要翻转，最小次数就是上一个字符为0或为1次数的最小值
        int len = s.length();
        int z = 0;
        int o = 0;
        for (int i = 0; i < len; i++) {

            if (s.charAt(i) == '0') {
                o = Math.min(z, o) + 1;
            } else {
                o = Math.min(z, o);
                z++;
            }
        }

        return Math.min(z, o);
    }
}
