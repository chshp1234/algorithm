package com.study.algorithm.algorithms.algorithmsJAVA;

import java.util.LinkedList;
import java.util.List;

//在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。
//
//如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；
//
//而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。
//
//
//
//给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。
//
// 
//
//示例 1：
//
//输入：label = 14
//输出：[1,3,4,14]
//示例 2：
//
//输入：label = 26
//输出：[1,2,6,10,26]
// 
//
//提示：
//
//1 <= label <= 10^6
//
//来源：力扣（LeetCode）
//链接：https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
public class 二叉树寻路 {
    public List<Integer> pathInZigZagTree(int label) {
        //数学，规律
        //1. 首先，我们把二叉树想象成一颗正常的顺序标记的二叉树（没有调换顺序）。
        //那么，对于当前节点node，其父节点为node/2，固对于label节点，我们先将其和所有其父节点加入列表。
        //2. 之后我们就需要考虑这个“之”字形状，由于每偶数层都是反向标记的，我们遍历的顺序跟原本二叉树肯定会有所不同：
        //    1. 对于最后层数是奇数的情况下，那么我们需要对偶数层的数进行重新获取
        //    2. 对于最后层数是偶数的情况下，那么我们需要对奇数层的数进行重新获取
        //3. 其实不管要改变奇数还是偶数层的数，方式都是一样的，都是以这一层中心为轴，对这个数进行镜像转换后的结果，
        //比如第三层的数4567，那么4进行转换后就是7，5进行转换后就是6（反过来同理）。
        //**注意这里**，我们可以想象成，最后是偶数层的情况下，原本二叉树每一层是从右到左进行顺序标记的；
        //而最后是奇数层的情况下，原本的二叉树每一层是从左到右进行顺序标记的。
        //4. 因为根节点是1，那么这颗完全二叉树正常顺序标记的情况下，每层第一个数为2^（i-1），且当前层总共节点数为2^(i-1)。转换的公式为3 * Math.pow(2, i) - 1 - result.get(i)。
        //5. 全部转换完后即可返回结果列表。

        //每次插入下标0的位置，用链表更合适
        List<Integer> result = new LinkedList<>();

        //将此二叉树以“正常”标记的顺序加入列表
        while (label > 0) {
            result.add(0, label);
            label = label / 2;
        }

        //层数
        int tier = result.size();
        //最后一层是否是奇数
        boolean isOdd = tier % 2 != 0;
        //如果是奇数，那么就要对偶数层中的结果进行转换；如果是偶数，就要对奇数层中的数进行转换
        for (int i = isOdd ? 1 : 2; i < tier; i = i + 2) {
            //对当前层i中的数result.get(i)做镜像转换，此公式也很简单，写一遍即可得出
            result.set(i, (int) (3 * Math.pow(2, i) - 1 - result.get(i)));
        }

        return result;
    }
}
