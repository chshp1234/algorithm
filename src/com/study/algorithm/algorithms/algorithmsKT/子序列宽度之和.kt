package com.study.algorithm.algorithms.algorithmsKT

//一个序列的 宽度 定义为该序列中最大元素和最小元素的差值。
//
//给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 109 + 7 取余 后的结果。
//
//子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。
//
// 
//
//示例 1：
//
//输入：nums = [2,1,3]
//输出：6
//解释：子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。
//相应的宽度是 0, 0, 0, 1, 1, 2, 2 。
//宽度之和是 6 。
//示例 2：
//
//输入：nums = [2]
//输出：0
// 
//
//提示：
//
//1 <= nums.length <= 105
//1 <= nums[i] <= 105
//
//来源：力扣（LeetCode）
//链接：https://leetcode.cn/problems/sum-of-subsequence-widths
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
class 子序列宽度之和 {
    fun sumSubseqWidths(nums: IntArray): Int {
        //排序，数学
        //题目说明子序列可以是任意几个元素组成，并且一个子序列的宽度等于子序列中最小值和最大值的差值
        //那么，不管这个子序列如何排列，其宽度都将是固定的
        //所以这个数组的排列顺序对结果是没有影响的
        //我们可以对数组进行排序，这样一个子序列的宽度，就很容易计算出来，为其最左侧元素和最右侧元素的差值
        //当我们固定序列两端(i,j)时，其中可以构成的所有子序列的数量为2^(j-i-1)
        //当i∈(0...j-1)，那么以j为结尾的子序列的总共的数量就为2^(j-1)+2^(j-2)+...+2^2+2^1+2^0=2^j
        //也就是以j为子序列最右侧（最大值），总共的子序列数量为2^j,那么以j为子序列最大值的数量为2^j
        //同理以j为最小值，子序列的数量为2^(nums.size-1-j)
        //所以，我们实时维护以每个元素为最大值时，子序列的长度，求出所有最大值之和max；以每个元素为最小值时，求出所有最小值之和min
        //那么最后的结果就是max-min

        val MOD = 1000000007
        nums.sort()

        //最右侧下标
        val right = nums.size - 1

        //最大值之和，初始为最左侧元素
        var max: Long = nums[0].toLong()
        //最小值之和，初始为最右侧元素
        var min: Long = nums[right].toLong()
        //子序列数量，初始为1
        var count: Long = 1

        //从1开始遍历，因为初始已经包含最大和最小值
        for (i in 1..right) {

            //计算当前子序列数量
            count = ((count * 2).rem(MOD))
            //最大值从左边开始计算
            max = (max + (count * nums[i])).rem(MOD)
            //最小值从右边开始计算
            min = (min + (count * nums[right - i])).rem(MOD)
        }

        //结果可能会溢出，所以这里加上MOD
        return (max - min + MOD).rem(MOD).toInt()
    }
}