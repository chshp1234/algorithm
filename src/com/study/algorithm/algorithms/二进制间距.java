package com.study.algorithm.algorithms;

import org.junit.Test;

//给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。如果不存在两个相邻的 1，返回 0 。
//
//如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 彼此 相邻 。两个 1 之间的距离是它们的二进制表示中位置的绝对差。例如，"1001" 中的两个 1 的距离为 3 。
//
// 
//
//示例 1：
//
//输入：n = 22
//输出：2
//解释：22 的二进制是 "10110" 。
//在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。
//第一对相邻的 1 中，两个 1 之间的距离为 2 。
//第二对相邻的 1 中，两个 1 之间的距离为 1 。
//答案取两个距离之中最大的，也就是 2 。
//示例 2：
//
//输入：n = 8
//输出：0
//解释：8 的二进制是 "1000" 。
//在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。
//示例 3：
//
//输入：n = 5
//输出：2
//解释：5 的二进制是 "101" 。
// 
//
//提示：
//
//1 <= n <= 109
//
//来源：力扣（LeetCode）
//链接：https://leetcode-cn.com/problems/binary-gap
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
public class 二进制间距 {
    @Test
    public void 二进制间距() {
        System.out.println("二进制间距：" + binaryGap(9));
    }

    public int binaryGap(int n) {

        //位运算
        //求出两个相邻间距的‘1’的值
        //用大的数除以小的数后，计算以2为底此数的对数（就是求2的几次方等于此数，就是两个'1'之间的间距）
        //更新维护最大步长

        int step = 0;
        //上一个最低位'1'代表的十进制数
        int last = n ^ (n = (n & (n - 1)));
        while (n > 0) {
            //当前最低位'1'代表的十进制数
            int current = n ^ (n = (n & (n - 1)));
            //求步长
            step = (int) Math.max(step, Math.log(current / last) / Math.log(2));
            last = current;
        }
        return step;
    }
}
